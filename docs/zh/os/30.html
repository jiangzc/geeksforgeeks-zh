<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-x-mtfrom-en"><head><meta http-equiv="X-Translated-By" content="Google"><link href="https://apachecn.github.io/geeksforgeeks-zh/docs/en/os/30.html" hreflang="en" rel="alternate machine-translated-from"><title></title><link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"></head><body><header class="entry-header"><h1 class="entry-title"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5FAA;&#x73AF;&#x8C03;&#x5EA6;&#x7A0B;&#x5E8F;|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x8BBE;&#x7F6E;1</span> </h1></header><!-- .entry-header --><div class="entry-content"><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> Round Robin&#x662F;&#x4E00;&#x79CD;<a href="http://quiz.geeksforgeeks.org/gate-notes-operating-system-process-scheduling/">CPU&#x8C03;&#x5EA6;&#x7B97;&#x6CD5;</a> &#xFF0C;&#x5176;&#x4E2D;&#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x4EE5;&#x5FAA;&#x73AF;&#x65B9;&#x5F0F;&#x5206;&#x914D;&#x56FA;&#x5B9A;&#x65F6;&#x9699;&#x3002;</span> </p><ul><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5B83;&#x7B80;&#x5355;&#xFF0C;&#x6613;&#x4E8E;&#x5B9E;&#x73B0;&#xFF0C;&#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x9965;&#x997F;&#xFF0C;&#x56E0;&#x4E3A;&#x6240;&#x6709;&#x8FDB;&#x7A0B;&#x90FD;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;&#x516C;&#x5E73;&#x7684;CPU&#x4EFD;&#x989D;&#x3002;</span> </li><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x4F5C;&#x4E3A;&#x6838;&#x5FC3;&#x7684;CPU&#x8C03;&#x5EA6;&#x4E2D;&#x6700;&#x5E38;&#x7528;&#x7684;&#x6280;&#x672F;&#x4E4B;&#x4E00;&#x3002;</span> </li><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5B83;&#x662F;&#x62A2;&#x5360;&#x5F0F;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x8FDB;&#x7A0B;&#x4EC5;&#x5728;&#x56FA;&#x5B9A;&#x7684;&#x65F6;&#x95F4;&#x7247;&#x5185;&#x5206;&#x914D;CPU&#x3002;</span> </li><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5B83;&#x7684;&#x7F3A;&#x70B9;&#x662F;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x5F00;&#x9500;&#x66F4;&#x5927;&#x3002;</span> </li></ul><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> <strong>&#x63D2;&#x56FE;&#xFF1A;</strong></span> <br><img src="../../../imgs/os/8fe4c31c0c3e60ddb4f432c1687fe1c6.jpg" alt="&#x5FAA;&#x73AF;&#x8D5B;" width="600" height="400" class="alignnone size-full wp-image-141108"></p><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> <strong>&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x7A0B;&#x5E8F;&#x8BA1;&#x7B97;Round Robin&#x4E2D;&#x7684;&#x6B21;&#x6570;&#xFF1F;</strong></span> </p><ol><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5B8C;&#x6210;&#x65F6;&#x95F4;&#xFF1A;&#x8FDB;&#x7A0B;&#x5B8C;&#x6210;&#x6267;&#x884C;&#x7684;&#x65F6;&#x95F4;&#x3002;</span> </li><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5468;&#x8F6C;&#x65F6;&#x95F4;&#xFF1A;&#x5B8C;&#x6210;&#x65F6;&#x95F4;&#x548C;&#x5230;&#x8FBE;&#x65F6;&#x95F4;&#x4E4B;&#x95F4;&#x7684;&#x65F6;&#x95F4;&#x5DEE;&#x3002;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x5468;&#x8F6C;&#x65F6;&#x95F4;=&#x5B8C;&#x6210;&#x65F6;&#x95F4; - &#x5230;&#x8FBE;&#x65F6;&#x95F4;</span> </li><li> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF08;WT&#xFF09;&#xFF1A;&#x8F6C;&#x5411;&#x65F6;&#x95F4;&#x548C;&#x7A81;&#x53D1;&#x65F6;&#x95F4;&#x4E4B;&#x95F4;&#x7684;&#x65F6;&#x95F4;&#x5DEE;&#x3002;</span> <br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x7B49;&#x5F85;&#x65F6;&#x95F4;=&#x5468;&#x8F6C;&#x65F6;&#x95F4; - &#x7A81;&#x53D1;&#x65F6;&#x95F4;</span> </li></ol><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> <em><strong>&#x5728;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5047;&#x8BBE;&#x5230;&#x8FBE;&#x65F6;&#x95F4;&#x4E3A;0&#xFF0C;&#x56E0;&#x6B64;&#x8F6C;&#x8EAB;&#x548C;&#x5B8C;&#x6210;&#x65F6;&#x95F4;&#x76F8;&#x540C;&#x3002;</strong></em></span> </p><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x68D8;&#x624B;&#x7684;&#x90E8;&#x5206;&#x662F;&#x8BA1;&#x7B97;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x3002;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x8BA1;&#x7B97;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x540E;&#xFF0C;&#x53EF;&#x4EE5;&#x5FEB;&#x901F;&#x8BA1;&#x7B97;&#x5468;&#x8F6C;&#x65F6;&#x95F4;&#x3002;</span> </p><br><!-- post_top_responsive --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> <strong>&#x67E5;&#x627E;&#x6240;&#x6709;&#x8FDB;&#x7A0B;&#x7684;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x7684;&#x6B65;&#x9AA4;&#xFF1A;</strong></span> </p><pre> <span class="pre-span" style="direction: ltr; text-align: left">1- Create an array <strong>rem_bt[]</strong> to keep track of remaining</span>
   <span class="pre-span" style="direction: ltr; text-align: left">burst time of processes.</span> <span class="pre-span" style="direction: ltr; text-align: left">This array is initially a</span> 
   <span class="pre-span" style="direction: ltr; text-align: left">copy of bt[] (burst times array)</span>
<span class="pre-span" style="direction: ltr; text-align: left">2- Create another array <strong>wt[]</strong> to store waiting times</span>
   <span class="pre-span" style="direction: ltr; text-align: left">of processes.</span> <span class="pre-span" style="direction: ltr; text-align: left">Initialize this array as 0.</span>
<span class="pre-span" style="direction: ltr; text-align: left">3- Initialize time : t = 0</span>
<span class="pre-span" style="direction: ltr; text-align: left">4- Keep traversing the all processes while all processes</span>
   <span class="pre-span" style="direction: ltr; text-align: left">are not done.</span> <span class="pre-span" style="direction: ltr; text-align: left">Do following for i&apos;th process if it is</span>
   <span class="pre-span" style="direction: ltr; text-align: left">not done yet.</span>
    <span class="pre-span" style="direction: ltr; text-align: left">a- If rem_bt[i] &gt; quantum</span>
       <span class="pre-span" style="direction: ltr; text-align: left">(i) t = t + quantum</span>
       <span class="pre-span" style="direction: ltr; text-align: left">(ii) bt_rem[i] -= quantum;</span>
    <span class="pre-span" style="direction: ltr; text-align: left">c- Else // Last cycle for this process</span>
       <span class="pre-span" style="direction: ltr; text-align: left">(i) t = t + bt_rem[i];</span>
       <span class="pre-span" style="direction: ltr; text-align: left">(ii) wt[i] = t - bt[i]</span>
       <span class="pre-span" style="direction: ltr; text-align: left">(ii) bt_rem[i] = 0;</span> <span class="pre-span" style="direction: ltr; text-align: left">// This process is over</span>
</pre><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x4E00;&#x65E6;&#x6211;&#x4EEC;&#x6709;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x53EF;&#x4EE5;&#x8BA1;&#x7B97;&#x4E00;&#x4E2A;&#x8FC7;&#x7A0B;&#x7684;&#x5468;&#x8F6C;&#x65F6;&#x95F4;tat [i]&#x4F5C;&#x4E3A;&#x7B49;&#x5F85;&#x548C;&#x7A81;&#x53D1;&#x65F6;&#x95F4;&#x7684;&#x603B;&#x548C;&#xFF0C;&#x5373;wt [i] + bt [i]</span> </p><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x4EE5;&#x4E0B;&#x662F;&#x4E0A;&#x8FF0;&#x6B65;&#x9AA4;&#x7684;&#x5B9E;&#x73B0;&#x3002;</span> </p><div class="responsive-tabs"><h2 class="tabtitle sigil_not_in_toc"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> C / C ++</span> </h2><div class="tabcontent">

<pre class="brush: cpp; highlight: [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109]; title: ; notranslate" title="">// C++ program for implementation of RR scheduling
#include&lt;iostream&gt;
using namespace std;

// Function to find the waiting time for all
// processes
void findWaitingTime(int processes[], int n,
             int bt[], int wt[], int quantum)
{
    // Make a copy of burst times bt[] to store remaining
    // burst times.
    int rem_bt[n];
    for (int i = 0 ; i &lt; n ; i++)
        rem_bt[i] =  bt[i];

    int t = 0; // Current time

    // Keep traversing processes in round robin manner
    // until all of them are not done.
    while (1)
    {
        bool done = true;

        // Traverse all processes one by one repeatedly
        for (int i = 0 ; i &lt; n; i++)
        {
            // If burst time of a process is greater than 0
            // then only need to process further
            if (rem_bt[i] &gt; 0)
            {
                done = false; // There is a pending process

                if (rem_bt[i] &gt; quantum)
                {
                    // Increase the value of t i.e. shows
                    // how much time a process has been processed
                    t += quantum;

                    // Decrease the burst_time of current process
                    // by quantum
                    rem_bt[i] -= quantum;
                }

                // If burst time is smaller than or equal to
                // quantum. Last cycle for this process
                else
                {
                    // Increase the value of t i.e. shows
                    // how much time a process has been processed
                    t = t + rem_bt[i];

                    // Waiting time is current time minus time
                    // used by this process
                    wt[i] = t - bt[i];

                    // As the process gets fully executed
                    // make its remaining burst time = 0
                    rem_bt[i] = 0;
                }
            }
        }

        // If all processes are done
        if (done == true)
          break;
    }
}

// Function to calculate turn around time
void findTurnAroundTime(int processes[], int n,
                        int bt[], int wt[], int tat[])
{
    // calculating turnaround time by adding
    // bt[i] + wt[i]
    for (int i = 0; i &lt; n ; i++)
        tat[i] = bt[i] + wt[i];
}

// Function to calculate average time
void findavgTime(int processes[], int n, int bt[],
                                     int quantum)
{
    int wt[n], tat[n], total_wt = 0, total_tat = 0;

    // Function to find waiting time of all processes
    findWaitingTime(processes, n, bt, wt, quantum);

    // Function to find turn around time for all processes
    findTurnAroundTime(processes, n, bt, wt, tat);

    // Display processes along with all details
    cout &lt;&lt; &quot;Processes &quot;&lt;&lt; &quot; Burst time &quot;
         &lt;&lt; &quot; Waiting time &quot; &lt;&lt; &quot; Turn around time\n&quot;;

    // Calculate total waiting time and total turn
    // around time
    for (int i=0; i&lt;n; i++)
    {
        total_wt = total_wt + wt[i];
        total_tat = total_tat + tat[i];
        cout &lt;&lt; &quot; &quot; &lt;&lt; i+1 &lt;&lt; &quot;\t\t&quot; &lt;&lt; bt[i] &lt;&lt;&quot;\t &quot;
             &lt;&lt; wt[i] &lt;&lt;&quot;\t\t &quot; &lt;&lt; tat[i] &lt;&lt;endl;
    }

    cout &lt;&lt; &quot;Average waiting time = &quot;
         &lt;&lt; (float)total_wt / (float)n;
    cout &lt;&lt; &quot;\nAverage turn around time = &quot;
         &lt;&lt; (float)total_tat / (float)n;
}

// Driver code
int main()
{
    // process id&apos;s
    int processes[] = { 1, 2, 3};
    int n = sizeof processes / sizeof processes[0];

    // Burst time of all processes
    int burst_time[] = {10, 5, 8};

    // Time quantum
    int quantum = 2;
    findavgTime(processes, n, burst_time, quantum);
    return 0;
}
</pre></div><h2 class="tabtitle sigil_not_in_toc"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> Java&#x7684;</span> </h2><div class="tabcontent"><pre class="brush: java; highlight: [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110]; title: ; notranslate" title="">// Java program for implementation of RR scheduling

public class GFG 
{
    // Method to find the waiting time for all
    // processes
    static void findWaitingTime(int processes[], int n,
                 int bt[], int wt[], int quantum)
    {
        // Make a copy of burst times bt[] to store remaining
        // burst times.
        int rem_bt[] = new int[n];
        for (int i = 0 ; i &lt; n ; i++)
            rem_bt[i] =  bt[i];
     
        int t = 0; // Current time
     
        // Keep traversing processes in round robin manner
        // until all of them are not done.
        while(true)
        {
            boolean done = true;
     
            // Traverse all processes one by one repeatedly
            for (int i = 0 ; i &lt; n; i++)
            {
                // If burst time of a process is greater than 0
                // then only need to process further
                if (rem_bt[i] &gt; 0)
                {
                    done = false; // There is a pending process
     
                    if (rem_bt[i] &gt; quantum)
                    {
                        // Increase the value of t i.e. shows
                        // how much time a process has been processed
                        t += quantum;
     
                        // Decrease the burst_time of current process
                        // by quantum
                        rem_bt[i] -= quantum;
                    }
     
                    // If burst time is smaller than or equal to
                    // quantum. Last cycle for this process
                    else
                    {
                        // Increase the value of t i.e. shows
                        // how much time a process has been processed
                        t = t + rem_bt[i];
     
                        // Waiting time is current time minus time
                        // used by this process
                        wt[i] = t - bt[i];
     
                        // As the process gets fully executed
                        // make its remaining burst time = 0
                        rem_bt[i] = 0;
                    }
                }
            }
     
            // If all processes are done
            if (done == true)
              break;
        }
    }
     
    // Method to calculate turn around time
    static void findTurnAroundTime(int processes[], int n,
                            int bt[], int wt[], int tat[])
    {
        // calculating turnaround time by adding
        // bt[i] + wt[i]
        for (int i = 0; i &lt; n ; i++)
            tat[i] = bt[i] + wt[i];
    }
     
    // Method to calculate average time
    static void findavgTime(int processes[], int n, int bt[],
                                         int quantum)
    {
        int wt[] = new int[n], tat[] = new int[n];
        int total_wt = 0, total_tat = 0;
     
        // Function to find waiting time of all processes
        findWaitingTime(processes, n, bt, wt, quantum);
     
        // Function to find turn around time for all processes
        findTurnAroundTime(processes, n, bt, wt, tat);
     
        // Display processes along with all details
        System.out.println(&quot;Processes &quot; + &quot; Burst time &quot; +
                      &quot; Waiting time &quot; + &quot; Turn around time&quot;);
     
        // Calculate total waiting time and total turn
        // around time
        for (int i=0; i&lt;n; i++)
        {
            total_wt = total_wt + wt[i];
            total_tat = total_tat + tat[i];
            System.out.println(&quot; &quot; + (i+1) + &quot;\t\t&quot; + bt[i] +&quot;\t &quot; +
                              wt[i] +&quot;\t\t &quot; + tat[i]);
        }
     
        System.out.println(&quot;Average waiting time = &quot; +
                          (float)total_wt / (float)n);
        System.out.println(&quot;Average turn around time = &quot; +
                           (float)total_tat / (float)n);
    }
    
    // Driver Method
    public static void main(String[] args)
    {
        // process id&apos;s
        int processes[] = { 1, 2, 3};
        int n = processes.length;
     
        // Burst time of all processes
        int burst_time[] = {10, 5, 8};
     
        // Time quantum
        int quantum = 2;
        findavgTime(processes, n, burst_time, quantum);
    }
}
</pre></div><h2 class="tabtitle sigil_not_in_toc"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"> C&#xFF03;</span> </h2><div class="tabcontent"><pre class="brush: csharp; highlight: [94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129]; title: ; notranslate" title="">// C# program for implementation of RR
// scheduling
using System;

public class GFG {
    
    // Method to find the waiting time
    // for all processes
    static void findWaitingTime(int []processes,
             int n, int []bt, int []wt, int quantum)
    {
        
        // Make a copy of burst times bt[] to 
        // store remaining burst times.
        int []rem_bt = new int[n];
        
        for (int i = 0 ; i &lt; n ; i++)
            rem_bt[i] = bt[i];
    
        int t = 0; // Current time
    
        // Keep traversing processes in round
        // robin manner until all of them are
        // not done.
        while(true)
        {
            bool done = true;
    
            // Traverse all processes one by
            // one repeatedly
            for (int i = 0 ; i &lt; n; i++)
            {
                // If burst time of a process
                // is greater than 0 then only
                // need to process further
                if (rem_bt[i] &gt; 0)
                {
                    
                    // There is a pending process
                    done = false;
    
                    if (rem_bt[i] &gt; quantum)
                    {
                        // Increase the value of t i.e.
                        // shows how much time a process
                        // has been processed
                        t += quantum;
    
                        // Decrease the burst_time of 
                        // current process by quantum
                        rem_bt[i] -= quantum;
                    }
    
                    // If burst time is smaller than
                    // or equal to quantum. Last cycle
                    // for this process
                    else
                    {
                        
                        // Increase the value of t i.e.
                        // shows how much time a process
                        // has been processed
                        t = t + rem_bt[i];
    
                        // Waiting time is current
                        // time minus time used by 
                        // this process
                        wt[i] = t - bt[i];
    
                        // As the process gets fully 
                        // executed make its remaining
                        // burst time = 0
                        rem_bt[i] = 0;
                    }
                }
            }
    
            // If all processes are done
            if (done == true)
            break;
        }
    }
    
    // Method to calculate turn around time
    static void findTurnAroundTime(int []processes,
               int n, int []bt, int []wt, int []tat)
    {
        // calculating turnaround time by adding
        // bt[i] + wt[i]
        for (int i = 0; i &lt; n ; i++)
            tat[i] = bt[i] + wt[i];
    }
    
    // Method to calculate average time
    static void findavgTime(int []processes, int n,
                             int []bt, int quantum)
    {
        int []wt = new int[n];
        int []tat = new int[n];
        int total_wt = 0, total_tat = 0;
    
        // Function to find waiting time of
        // all processes
        findWaitingTime(processes, n, bt, wt, quantum);
    
        // Function to find turn around time
        // for all processes
        findTurnAroundTime(processes, n, bt, wt, tat);
    
        // Display processes along with
        // all details
        Console.WriteLine(&quot;Processes &quot; + &quot; Burst time &quot; +
                    &quot; Waiting time &quot; + &quot; Turn around time&quot;);
    
        // Calculate total waiting time and total turn
        // around time
        for (int i = 0; i &lt; n; i++)
        {
            total_wt = total_wt + wt[i];
            total_tat = total_tat + tat[i];
            Console.WriteLine(&quot; &quot; + (i+1) + &quot;\t\t&quot; + bt[i] 
                         + &quot;\t &quot; + wt[i] +&quot;\t\t &quot; + tat[i]);
        }
    
        Console.WriteLine(&quot;Average waiting time = &quot; +
                        (float)total_wt / (float)n);
        Console.Write(&quot;Average turn around time = &quot; +
                        (float)total_tat / (float)n);
    }
    
    // Driver Method
    public static void Main()
    {
        // process id&apos;s
        int []processes = { 1, 2, 3};
        int n = processes.Length;
    
        // Burst time of all processes
        int []burst_time = {10, 5, 8};
    
        // Time quantum
        int quantum = 2;
        findavgTime(processes, n, burst_time, quantum);
    }
}

// This code is contributed by nitin mittal.
</pre><p></p></div></div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()">&#x8F93;&#x51FA;&#xFF1A;</span> <p></p><pre> <span class="pre-span" style="direction: ltr; text-align: left">Processes Burst time Waiting time Turn around time</span>
 <span class="pre-span" style="direction: ltr; text-align: left">1 10 13 23</span>
 <span class="pre-span" style="direction: ltr; text-align: left">2 5 10 15</span>
 <span class="pre-span" style="direction: ltr; text-align: left">3 8 13 21</span>
<span class="pre-span" style="direction: ltr; text-align: left">Average waiting time = 12</span>
<span class="pre-span" style="direction: ltr; text-align: left">Average turn around time = 19.6667</span>
</pre><br><!-- post_bottom_responsive --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins><br><br><!-- .entry-meta --></div></body></html>