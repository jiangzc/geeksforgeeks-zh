<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Convoy Effect in Operating Systems</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p><strong>Prerequisites :</strong> Basics of FCFS Scheduling (<a href="https://www.geeksforgeeks.org/program-fcfs-scheduling-set-1/" target="_blank">Program for FCFS Scheduling | Set 1</a>, <a href="https://www.geeksforgeeks.org/program-fcfs-scheduling-set-2-processes-different-arrival-time/" target="_blank">Program for FCFS Scheduling | Set 2 </a>)</p>
<p>Convoy Effect is phenomenon associated with the First Come First Serve (FCFS) algorithm, in which the whole Operating System slows down due to few slow processes.  </p>
<p><img src="../../../imgs/os/7314f2f1dbd2540baa119b4dc5a20e78.jpg" width="693" height="190" alt="" class="aligncenter size-full"/></p>
<p>FCFS algorithm is non-preemptive in nature, that is, once CPU time has been allocated to a process, other processes can get CPU time only after the current process has finished. This property of FCFS scheduling leads to the situation called Convoy Effect.</p>
<p>Suppose there is one CPU intensive (large burst time) process in the ready queue, and several other processes with relatively less burst times but are Input/Output (I/O) bound (Need I/O operations frequently).</p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<p>The following then takes place – </p>
<ul>
<li>The I/O bound processes are first allocated CPU time. As they are less CPU intensive, the quickly get executed and then goto I/O queues.</li>
<li>Now, the CPU intensive process is allocated CPU time. As its burst time is high, it takes time to complete.</li>
<li>While the CPU intensive process is being executed, the I/O bound processes complete their I/O operations and are moved back to ready queue.</li>
<li>However, the I/O bound processes are made to wait as the CPU intensive process still hasn’t finished. <strong>This leads to I/O devices being idle.</strong></li>
<li>When the CPU intensive process gets over, it is sent to the I/O queue so that it can access and I/O device.</li>
<li>Meanwhile, the I/O bound processes get their required CPU time and move back to I/O queue.</li>
<li>However, they are made to wait because the CPU intensive process is still accessing an I/O device. As a result, <strong>the CPU is sitting idle now</strong>.</li>
</ul>
<p>Hence in Convoy Effect, one slow process slows down the performance of the entire set of processes, and leads to wastage of CPU time and other devices.</p>
<p>To avoid Convoy Effect, preemptive scheduling algorithms like Round Robin Scheduling can be used – as the smaller processes don’t have to wait much for CPU time – making their execution faster and leading to less resources sitting idle.</p>
<p>References – </p>
<ul>
<li>A. Silberschatz, P. Galvin, G. Gagne, “Operating Systems Concepts (8th Edition)”, Wiley India Pvt. Ltd.</li>
</ul>


<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>