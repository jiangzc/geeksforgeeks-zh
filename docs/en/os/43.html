<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Inter Process Communication</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>A process can be of two type:</p>
<ul>
<li> Independent process.</li>
<li>Co-operating process.</li>
</ul>
<p>An independent process is not affected by the execution of other processes while a co-operating process can be affected by other executing processes. Though one can think that those processes, which are running independently, will execute very efficiently but in practical, there are many situations when co-operative nature can be utilised for increasing computational speed, convenience and modularity. Inter process communication (IPC) is a mechanism which allows processes to communicate each other and synchronize their actions. The communication between these processes can be seen as a method of co-operation between them. Processes can communicate with each other using these two ways:<br/>
</p>
<ol>
<li>Shared Memory</li>
<li>Message passing</li>
</ol>
<p>The Figure 1 below shows a basic structure of communication between processes via shared memory method and via message passing.</p>
<p>An operating system can implement both method of communication. First, we will discuss the shared memory method of communication and then message passing. Communication between processes using shared memory requires processes to share some variable and it completely depends on how programmer will implement it. One way of communication using shared memory can be imagined like this: Suppose process1 and process2 are executing simultaneously and they share some resources or use some information from other process, process1 generate information about certain computations or resources being used and keeps it as a record in shared memory. When process2 need to use the shared information, it will check in the record stored in shared memory and take note of the information generated by process1 and act accordingly. Processes can use shared memory for extracting information as a record from other process as well as for delivering any specific information to other process. <br/>
Let’s discuss an example of communication between processes using shared memory method.</p>
<p><img src="../../../imgs/os/13e13f09e1a4bf07a85ef72f591cd8b4.jpg" width="538" height="304" alt="" class="aligncenter size-full"/></p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<p align="center"><strong>i) Shared Memory Method</strong></p>
<p><strong>Ex: Producer-Consumer problem  </strong><br/>
There are two processes: Producer and Consumer. Producer produces some item and Consumer consumes that item. The two processes shares a common space or memory location known as buffer where the item produced by Producer is stored and from where the Consumer consumes the item if needed. There are two version of this problem: first one is known as unbounded buffer problem in which Producer can keep on producing items and there is no limit on size of buffer, the second one is known as bounded buffer problem in which producer can produce up to a certain amount of item and after that it starts waiting for consumer to consume it. We will discuss the bounded buffer problem. First, the Producer and the Consumer will share some common memory, then producer will start producing items. If the total produced item is equal to the size of buffer, producer will wait to get it consumed by the Consumer. Sim-<br/>
ilarly, the consumer first check for the availability of the item and if no item is available, Consumer will wait for producer to produce it. If there are items available, consumer will consume it. The pseudo code are given below:<br/><br/>
<strong>Shared Data between the two Processes</strong></p>
<pre class="brush: c; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]; title: ; notranslate" title="">#define buff_max 25
#define mod %

    struct item{

        // diffrent member of the produced data 
        // or consumed data    
        ---------
    }
    
    // An array is needed for holding the items. 
    // This is the shared place which will be  
    // access by both process   
    // item shared_buff [ buff_max ];
     
    // Two variables which will keep track of 
    // the indexes of the items produced by producer 
    // and consumer The free index points to 
    // the next free index. The full index points to 
    // the first full index. 
    int free_index = 0;
    int full_index = 0;
  

</pre>
<p><strong>Producer Process Code</strong></p>
<pre class="brush: c; highlight: [1,2,3,4,5,6,7,8,9,10,11,12]; title: ; notranslate" title="">item nextProduced;
    
    while(1){
        
        // check if there is no space 
        // for production.
        // if so keep waiting.
        while((free_index+1) mod buff_max == full_index);
        
        shared_buff[free_index] = nextProduced;
        free_index = (free_index + 1) mod buff_max;
    }
</pre>
<p><strong>Consumer Process Code</strong></p>
<pre class="brush: c; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; title: ; notranslate" title="">item nextConsumed;
    
    while(1){
        
        // check if there is an available 
        // item  for consumption. 
        // if not keep on waiting for 
        // get them produced.
        while((free_index == full_index);
        
        nextConsumed = shared_buff[full_index];
        full_index = (full_index + 1) mod buff_max;
    }
</pre>
<p>
In the above code, The producer will start producing again when the (free_index+1) mod buff max will be free because if it it not free, this implies that there are still items that can be consumed by the Consumer so there is no need to produce more. Similarly, if free index and full index points to the same index, this implies that there are no item to consume.<br/>
<br/><br/></p>
<p align="center"><strong>ii) Messaging Passing Method</strong></p>
<p>Now, We will start our discussion for the communication between processes via message passing. In this method, processes communicate with each other without using any kind of of shared memory. If two processes p1 and p2 want to communicate with each other, they proceed as follow:<br/>
</p>
<ul>
<li>Establish a communication link (if a link already exists, no need to establish it again.)</li>
<li>Start exchanging messages using basic primitives.<br/>
We need at least two primitives:<br/>
– <strong>send</strong>(message, destinaion) or <strong>send</strong>(message)<br/>
– <strong>receive</strong>(message, host) or <strong>receive</strong>(message)</li>
</ul>
<p><img src="../../../imgs/os/8bf712ad9df2880e9c7a71eb13fede1b.jpg" width="423" height="284" alt="" class="aligncenter size-full"/></p>
<p>
The message size can be of fixed size or of variable size. if it is of fixed size, it is easy for OS designer but complicated for programmer and if it is of variable size then it is easy for programmer but complicated for the OS designer. A standard message can have two parts: <strong>header and body.</strong><br/>
The <strong>header part</strong> is used for storing Message type, destination id, source id, message length and control information. The control information contains information like what to do if runs out of buffer space, sequence number, priority. Generally, message is sent using FIFO style.</p>
<p><br/></p>
<p align="center"><strong>Message Passing through Communication Link.</strong></p>
<p><strong>Direct and Indirect Communication link</strong><br/>
Now, We will start our discussion about the methods of implementing communication link. While implementing the link, there are some questions which need to be kept in mind like :</p>
<ol>
<li>How are links established?</li>
<li>Can a link be associated with more than two processes?</li>
<li>How many links can there be between every pair of communicating processes?</li>
<li> What is the capacity of a link? Is the size of a message that the link can accommodate fixed or variable?</li>
<li>Is a link unidirectional or bi-directional?</li>
</ol>
<p>A link has some capacity that determines the number of messages that can reside in it temporarily for which Every link has a queue associated with it which can be either of zero capacity or of bounded capacity or of unbounded capacity. In zero capacity, sender wait until receiver inform sender that it has received the message. In non-zero capacity cases, a process does not know whether a message has been received  or not after the send operation. For this, the sender must communicate to receiver explicitly. Implementation of the link depends on the situation, it can be either a Direct communication link or an In-directed communication link.<br/>
 <strong>Direct Communication links</strong> are implemented when the processes use specific process identifier for the communication but it is hard to identify the sender ahead of time.<br/>
<strong>For example: the print server.</strong><br/>
<br/>
<strong>In-directed Communication</strong> is done via a shred mailbox (port), which consists of queue of messages. Sender keeps the message in mailbox and receiver picks them up.</p>
<p><br/></p>
<p align="center"><strong>Message Passing through Exchanging the Messages.</strong></p>
<p><strong>Synchronous and Asynchronous Message Passing:</strong><br/>
A process that is blocked is one that is waiting for some event, such as a resource becoming available or the completion of an I/O operation. IPC is possible between the processes on same computer as well as on the processes running on different computer i.e. in networked/distributed system. In both cases, the process may or may not be blocked while sending a message or attempting to receive a message so Message passing may be blocking or non-blocking. Blocking is considered <strong>synchronous</strong> and <strong>blocking send</strong> means the sender will be blocked until the message is received by receiver. Similarly, <strong>blocking receive</strong> has the receiver block until a message is available. Non-blocking is considered <strong>asynchronous</strong> and Non-blocking send has the sender sends the message and continue. Similarly, Non-blocking receive has the receiver receive a valid message or null. After a careful analysis, we can come to a conclusion that, for a sender it is more natural to be non-blocking after message passing as there may be a need to send the message to different processes But the sender expect acknowledgement from receiver in case the send fails. Similarly, it is more natural for a receiver to be blocking after issuing the receive as the information from the received message may be used for further execution but at the same time, if the message send keep on failing, receiver will have to wait for indefinitely. That is why we also consider the other possibility of message passing. There are basically three most preferred combinations:</p>
<ul>
<li>Blocking send and blocking receive</li>
<li>Non-blocking send and Non-blocking receive</li>
<li>Non-blocking send and Blocking receive (Mostly used)</li>
</ul>
<p><strong>In Direct message passing</strong>, The process which want to communicate must explicitly name the recipient or sender of communication.<br/>
 e.g. <strong>send(p1, message)</strong> means send the message to p1.<br/>
similarly, <strong>receive(p2, message)</strong> means receive the message from p2.<br/>
In this method of communication, the communication link get established automatically, which can be either unidirectional or bidirectional, but one link can be used between one pair of the sender and receiver and one pair of sender and receiver should not possess more than one pair of link. Symmetry and asymmetry between the sending and receiving can also be implemented i.e. either both process will name each other for sending and receiving the messages or only sender will name receiver for sending the message and there is no need for receiver for naming the sender for receiving the message.The problem with this method of communication is that if the name of one process changes, this method will not work.<br/>
<br/>
<strong>In Indirect message passing</strong>, processes uses mailboxes (also referred to as ports) for sending and receiving messages. Each mailbox has a unique id and processes can communicate only if they share a mailbox. Link established only if processes share a common mailbox and a single link can be associated with many processes. Each pair of processes can share several communication links and these link may be unidirectional or bi-directional. Suppose two process want to communicate though Indirect message passing, the required operations are: create a mail box, use this mail box for sending and receiving messages, destroy the mail box. The standard primitives used are : <strong>send(A, message)</strong> which means send the message to mailbox A. The primitive for the receiving the message also works in the same way e.g. <strong>received (A, message)</strong>. There is a problem in this mailbox implementation. Suppose there are more than two processes sharing the same mailbox and suppose the process p1 sends a message to the mailbox, which process will be the receiver? This can be solved by either forcing that only two processes can share a single mailbox or enforcing that only one process is allowed to execute the receive at a given time or select any process randomly and notify the sender about the receiver. A mailbox can be made private to a single sender/receiver pair and can also be shared between multiple sender/receiver pairs. Port is an implementation of such mailbox which can have multiple sender and single receiver. It is used in client/server application (Here server is the receiver). The port is owned by the receiving process and created by OS on the request of the receiver process and can be destroyed either on request of the same receiver process or when the receiver terminates itself. Enforcing that only one process is allowed to execute the receive can be done using the concept of mutual exclusion. <strong>Mutex mailbox</strong> is create which is shared by n process. Sender is non-blocking and sends the message. The first process which executes the receive will enter in the critical section and all other processes will be blocking and will wait.<br/>
<br/>
Now, lets discuss the Producer-Consumer problem using message passing concept. The producer place items (inside messages) in the mailbox and the consumer can consume item when at least one message present in the mailbox. The code are given below:<br/>
<br/>
<strong>Producer Code</strong></p>
<pre class="brush: c; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate" title="">void Producer(void){
        
        int item;
        Message m;
        
        while(1){
            
            receive(Consumer, &amp;m);
            item = produce();
            build_message(&amp;m , item ) ;
            send(Consumer, &amp;m);
        }
    }
</pre>
<p><strong>Consumer Code</strong></p>
<pre class="brush: c; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate" title="">void Consumer(void){
        
        int item;
        Message m;
        
        while(1){
            
            receive(Producer, &amp;m);
            item = extracted_item();
            send(Producer, &amp;m);
            consume_item(item);
        }
    }
</pre>
<p><strong>Examples of IPC systems</strong></p>
<ol>
<li> Posix : uses shared memory method.</li>
<li>Mach : uses message passing</li>
<li>Windows XP : uses message passing using local procedural calls</li>
</ol>
<p>
<strong>Communication in client/server Architecture:</strong></p>
<p>There are various mechanism:</p>
<ul>
<li>Pipe</li>
<li>Socket</li>
<li>Remote Procedural calls (RPCs)</li>
</ul>
<p>The above three methods will be discussed later article as all of them are quite conceptual and deserve their own separate articles.<br/>
</p>
<p><strong>References:</strong></p>
<ol>
<li> Operating System Concepts by Galvin et al.</li>
<li>Lecture notes/ppt of Ariel J. Frank, Bar-Ilan University</li>
</ol>
<p>More Reference:<br/>
<a href="http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf">http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf</a><br/>
<a href="https://www.youtube.com/watch?v=lcRqHwIn5Dk">https://www.youtube.com/watch?v=lcRqHwIn5Dk</a></p>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>