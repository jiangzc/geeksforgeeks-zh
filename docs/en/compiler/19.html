<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>

<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Parsing | Set 1 (Introduction, Ambiguity and Parsers)</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>In this article we will study about various types of parses. It is one of the most important topic in Compiler from GATE point of view. The working of various parsers will be explained from GATE question solving point of view.<br/>
<strong>Prerequisite</strong> – basic knowledge of grammars, parse trees, ambiguity.</p>
<h2 class="sigil_not_in_toc">Role of the parser :</h2>
<p>In the syntax analysis phase, a compiler verifies whether or not the tokens generated by the lexical analyzer are grouped according to the syntactic rules of the language. This is done by a parser. The parser obtains a string of tokens from the lexical analyzer and verifies that the string can be the grammar for the source language. It detects and reports any syntax errors and produces a parse tree from which intermediate code can be generated.<br/>
<img class="aligncenter size-full wp-image-164626" src="../../../imgs/compiler/251a72261ea040bd9051bc2b0cbbc683.jpg" alt="position of parser" width="885" height="335"/><br/>
Before going to types of parsers we will discuss on some ideas about the some important things required for understanding parsing.</p>
<p><strong>Context Free Grammers</strong>:<br/>
The syntax of a programming language is described by a context free grammar (CFG). CFG consists of set of terminals, set of non terminals, a start symbol and set of productions.<br/>
Notation – &#160; α → β where α is a single variable [V]<br/>
β ∈ (V+T)*</p>
<p><strong>Ambiguity</strong><br/>
A grammar that produces more than one parse tree for some sentence is said to be ambiguous.<br/>
Eg- consider a grammar<br/>
S -&gt; aS | Sa | a<br/>
Now for string aaa we will have 4 parse trees, hence ambiguous<br/>
<img src="../../../imgs/compiler/0486f99be0f5bc5c7fedb96406dec0cb.jpg" alt="parse tree" width="450" height="600" class="aligncenter size-medium wp-image-164631"/><br/>
For more information refer <a href="http://quiz.geeksforgeeks.org/ambiguous-grammar/" rel="noopener" target="_blank">quiz.geeksforgeeks.org/ambiguous-grammar/</a></p>
<p><strong>Removing Left Recursion :</strong><br/>
A grammar is left recursive if it has a non terminal (variable) S such that their is a derivation<br/>
S -&gt; Sα | β<br/>
where α ∈ (V+T)* and β ∈ (V+T)* (sequence of terminals and non terminals that do not start with S)<br/>
Due to the presence of left recursion some top down parsers enter into infinite loop so we have to eliminate left recursion.<br/>
Let the productions is of the form A -&gt; Aα<sub>1</sub> | Aα<sub>2</sub> | Aα<sub>3</sub> | ….. | Aα<sub>m</sub> | β<sub>1</sub> | β<sub>2</sub> | …. | β<sub>n</sub><br/>
Where no βi begins with an A . then we replace the A-productions by<br/>
A -&gt; β<sub>1</sub> A’ | β<sub>2</sub> A’ | ….. | β<sub>n</sub> A’<br/>
A’ -&gt; α<sub>1</sub>A’ | α<sub>2</sub>A’ | α<sub>3</sub>A’| ….. | α<sub>m</sub>A’ | ε<br/>
The nonterminal A generates the same strings as before but is no longer left recursive.<br/>
Let’s look at some example to understand better</p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<p><img src="../../../imgs/compiler/0573dadaa61532180995bd1bf3240b61.jpg" class="ql-img-inline-formula quicklatex-auto-format" alt="   \\ Example 1: \\ \\S\rightarrow S\overset{\alpha _{1}}{ab} \hspace{2 mm}/\hspace{2 mm} S\overset{\alpha _{2}}{cd} \hspace{2 mm}/ \hspace{2 mm}S\overset{\alpha _{3}}{ef}\hspace{2 mm} /\hspace{2 mm} \overset{\beta_{1}}{g}\hspace{2 mm}/\hspace{2 mm}\overset{\beta_{2}}{h}\\ \\ S\rightarrow gS'/hS'\\ \\ S'\rightarrow \epsilon /abS'/cdS'/efS' \\ \\ Example 2:\\ \\ S\rightarrow (L)/a \hspace{2 cm} No\hspace{2 mm} left\hspace{2 mm} Recursion\\  \\  L\rightarrow  L,S/S \hspace{2 cm} left\hspace{2 mm} Recursion\\  \\ L\rightarrow Sl' \\ \\ L'\rightarrow \epsilon/ SL' \\         " title="Rendered by QuickLaTeX.com" height="448" width="393" style="vertical-align: 47px;"/></p>
<p><strong>Removing Left Factoring :</strong><br/>
A grammar is said to be left factored when it is of the form –<br/>
A -&gt; αβ<sub>1</sub> | αβ<sub>2</sub> | αβ<sub>3</sub> | …… | αβ<sub>n</sub> | γ  i.e the productions start with the same terminal (or set of terminals). On seeing the input α we cannot immediately tell which production to choose to expand A.<br/>
Left factoring is a grammar transformation that is useful for producing a grammar suitable for predictive or top down parsing. When the choice between two alternative A-productions is not clear, we may be able to rewrite the productions to defer the decision until enough of the input has been seen to make the right choice.<br/>
For the grammar A -&gt; αβ<sub>1</sub> | αβ<sub>2</sub> | αβ<sub>3</sub> | …… | αβ<sub>n</sub> | γ<br/>
The equivalent left factored grammar will be –<br/>
A -&gt; αA’ | γ<br/>
A’ -&gt; β<sub>1</sub> | β<sub>2</sub> | β<sub>3</sub> | …… | β<sub>n</sub><br/>
<br/><br/>
<img src="../../../imgs/compiler/4464d8dc459c548032810ec4c2be5c51.jpg" class="ql-img-inline-formula quicklatex-auto-format" alt="   \\ \\ Example 1: \\ \\ S\rightarrow iEtS\hspace{2 mm} / \hspace{2 mm} iEtS eS/a/b \\ \\  S\rightarrow iEtSS'/a/b\\ \\  S'\rightarrow eS/ \epsilon  \\ \\  Example 2:\\ \\ S\rightarrow a/ab/abc/abcd/e/f\\ \\ S\rightarrow aS'/e/f \\ \\ S'\rightarrow bS&quot;/\epsilon \hspace{2 cm} -for\hspace{2 mm} single\hspace{2 mm} a \\ \\ S&quot;\rightarrow cS'''/\epsilon  \hspace{2 cm} -for\hspace{2 mm} ab \\ \\ S'''\rightarrow  d/\epsilon  \hspace{2.4 cm} -for\hspace{2 mm} abc \\ " title="Rendered by QuickLaTeX.com" height="570" width="363" style="vertical-align: 21px;"/></p>
<p>The process of deriving the string from the given grammar is known as derivation (parsing).<br/>
Depending upon how derivation is done we have two kinds of parsers :-</p>
<ol>
<li>Top Down Parser</li>
<li>Bottom Up Parser</li>
</ol>
<p>We will be studying the parsers from GATE point of view.</p>
<p><strong>Top Down Parser</strong><br/>
Top down parsing attempts to build the parse tree from root to leave. Top down parser will start from start symbol and proceeds to string. It follows leftmost derivation. In leftmost derivation, the leftmost non-terminal in each sentential is always chosen.</p>
<p><strong>Recursive Decent Parsing</strong></p>
<pre>S()
{     Choose any S production, S -&gt;X<sub>1</sub>X<sub>2</sub>…..Xk;
      for (i = 1 to k)
      {
          If ( Xi is a non-terminal)
          Call procedure Xi();
          else if ( Xi equals the current input, increment input)
          Else /* error has occurred, backtrack and try another possibility */
      }
}
</pre>
<p>Lets understand it better with an example<br/>
<img src="../../../imgs/compiler/200a62f00b63280bb9ef830a6f408cf2.jpg" class="ql-img-inline-formula quicklatex-auto-format" alt="   \\ \\  S\rightarrow ABC/DEF/GHI \hspace{4.5 cm} G\rightarrow d\\ \\  A\rightarrow ab/gh/m\hspace{6 cm} F\rightarrow d \\ \\  B\rightarrow cd/ij/n  \hspace{6.2 cm} H\rightarrow e  \\ \\  C\rightarrow ef/kl/o  \hspace{6.1 cm} I\rightarrow f\\ \\  S\rightarrow aS'/e/f\\ \\  D\rightarrow a \\ \\  E\rightarrow b\hspace{6.1 cm} Input:abijef\\ \\ \\  " title="Rendered by QuickLaTeX.com" height="437" width="460" style="vertical-align: 89px;"/><br/>
<img src="../../../imgs/compiler/39d1bca5ceca67dda6c74f6c65dec664.jpg" alt="Recursive Decent Parsing" width="650" height="450"/></p>
<p><br/><br/>
A recursive descent parsing program consist of a set of procedures, one for each nonterminal. Execution begins with the procedure for the start symbol which halts if its procedure body scans the entire input string.</p>
<p><strong>Non Recursive Predictive Parsing :</strong><br/>
This type if parsing does not require backtracking. Predictive parsers can be constructed for LL(1) grammar, the first ‘L’ stands for scanning the input from left to right, the second ‘L’ stands for leftmost derivation and ‘1’ for using one input symbol lookahead at each step to make parsing action decisions.<br/>
Before moving on to LL(1) parsers please go through FIRST and FOLLOW<br/>
<a href="http://quiz.geeksforgeeks.org/compiler-design-first-in-syntax-analysis/">http://quiz.geeksforgeeks.org/compiler-design-first-in-syntax-analysis/</a><br/>
<a href="http://quiz.geeksforgeeks.org/compiler-design-follow-set-in-syntax-analysis/">http://quiz.geeksforgeeks.org/compiler-design-follow-set-in-syntax-analysis/</a></p>
<p><strong>Construction of LL(1)predictive parsing table</strong></p>
<p>For each production A -&gt; α repeat following steps –<br/>
Add A -&gt; α under M[A, b] for all b in FIRST(α)<br/>
If FIRST(α) contains ε then add A -&gt; α under M[A,c] for all c in FOLLOW(A).<br/>
Size of parsing table = (No. of terminals + 1) * #variables</p>
<p>Eg – consider the grammar<br/>
S -&gt; (L) | a<br/>
L -&gt; SL’<br/>
L’ -&gt; ε | SL’<br/>
<img src="../../../imgs/compiler/5cd19b94c7923e6bb8340628a34940e9.jpg" alt="LL 1 grammer" width="793" height="401" class="aligncenter size-full wp-image-164637"/><br/>
<img src="../../../imgs/compiler/c4e8be32ac8694a03f684f02a7ba35ac.jpg" alt="https://contribute.geeksforgeeks.org/wp-content/uploads/multipleentriesllgrammar.jpg"/><br/>
For any grammar if M have multiple entries than it is not LL(1) grammar<br/>
Eg –<br/>
<img src="../../../imgs/compiler/8567cc6af262fd1cc20d656cfb0d45b1.jpg" alt="not LL 1 grammer" width="723" height="435" class="aligncenter size-full wp-image-164638"/></p>
<p><img src="../../../imgs/compiler/249cd6663b4cf5118fa30999a1ac3902.jpg" alt="grammer"/></p>
<p>Important Notes</p>
<pre>      1. If a grammar contain left factoring then it can not be LL(1)
        Eg - S -&gt; aS | a      ---- both productions go in a
      2. If a grammar contain left recursion it can not be LL(1)
        Eg - S -&gt; Sa | b 
                S -&gt; Sa goes to FIRST(S) = b
                S -&gt; b goes to b, thus b has 2 entries hence not LL(1)
      3. If a grammar is ambiguous then it can not be LL(1)
      4. Every regular grammar need not be LL(1) because 
         regular grammar may contain left factoring, left recursion or ambiguity. 
</pre>
<p><a href="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/circle-6.jpg"><img class="alignnone size-full wp-image-30810" src="../../../imgs/compiler/2a7b480df9f424cd1b99877d291d11e5.jpg" alt="parser_9" width="404" height="379"/></a><br/>
We will discuss Bottom Up parser in next article (<a href="https://www.geeksforgeeks.org/parsing-set-2-bottom-up-or-shift-reduce-parsers/" rel="noopener" target="_blank">Set 2</a>).</p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>