<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>

<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Parsing | Set 3 (SLR, CLR and LALR Parsers)</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>In this article we are discussing the SLR parser, CLR parser and LALR parser which are the parts of Bottom Up parser.<br/>
<br/>
<strong>SLR Parser</strong><br/>
The SLR parser is similar to LR(0) parser except that the reduced entry. The reduced productions are written only in the FOLLOW of the variable whose production is reduced.<br/>
<br/>
<strong>Construction of SLR parsing table –</strong></p>
<ol>
<li>Construct C = { I<sub>0</sub>, I<sub>1</sub>, ……. I<sub>n</sub>}, the collection of sets of LR(0) items for G’.</li>
<li>State i is constructed from Ii. The parsing actions for state i are determined as follow :
<ul>
<li>If [ A -&gt; ?.a? ] is in I<sub>i</sub> and GOTO(I<sub>i</sub> , a) = I<sub>j</sub> , then set ACTION[i, a] to “shift j”. Here a must be terminal.</li>
<li> If [A -&gt; ?.] is in I<sub>i</sub>, then set ACTION[i, a] to “reduce A -&gt; ?” for all a in FOLLOW(A); here A may not be S’.</li>
<li> Is [S -&gt; S.] is in I<sub>i</sub>, then set action[i, $] to “accept”. If any conflicting actions are generated by the above rules we say that the grammar is not SLR. </li>
</ul>
</li>
<li>The goto transitions for state i are constructed for all nonterminals A using the rule:<br/>
 if GOTO( I<sub>i</sub> , A ) = I<sub>j</sub> then GOTO [i, A] = j.</li>
<li>All entries not defined by rules 2 and 3 are made error. </li>
</ol>
<p>Eg:<br/>
If in the parsing table we have multiple entries then it is said to be a conflict.</p>
<pre>Consider the grammar E -&gt; T+E | T
                     T -&gt;id
    Augmented grammar - E’ -&gt; E
                E -&gt; T+E | T
                T -&gt; id

</pre>
<p><a href="https://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/parser_16.png"><img src="../../../imgs/compiler/209bb0089f82b4a6f50475a65361aa16.jpg" alt="parser_16" width="630" height="508" class="alignnone size-full wp-image-30904"/></a></p>
<p><strong>Note 1 </strong>– for GATE we don’t have to draw the table, in the GOTO graph just look for the reduce and shifts occurring together in one state.. In case of two reductions,if the follow of both the reduced productions have something common then it will result in multiple entries in table hence not SLR. In case of one shift and one reduction,if their is a GOTO operation from that state on a terminal which is the follow of the reduced production than it will result in multiple entries hence not SLR.<br/>
<strong>Note 2</strong> – Every SLR grammar is unambiguous but their are many unambiguous grammars that are not SLR.<br/>
<br/>
<strong>CLR PARSER</strong></p>
<p>In the SLR method we were working with LR(0)) items. In CLR parsing we will be using LR(1) items. LR(k) item is defined to be an item using lookaheads of length k. So , the LR(1) item is comprised of two parts : the LR(0) item and the lookahead associated with the item.<br/>
LR(1) parsers are more powerful parser.<br/>
For LR(1) items we modify the Closure and GOTO function.<br/>
<br/>
<strong>Closure Operation </strong></p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<pre>Closure(I)
repeat 
    for (each item [ A -&gt; ?.B?, a ] in I )
        for (each production B -&gt; ? in G’)
          for (each terminal b in FIRST(?a))
            add [ B -&gt; .? , b ] to set I;
until no more items are added to I;
return I;

</pre>
<p>Lets understand it with an example –<br/>
<a href="https://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/parser_17.png"><img src="../../../imgs/compiler/76e0de2e4b27249d7e055e6cc54909e2.jpg" alt="parser_17" width="617" height="398" class="alignnone size-full wp-image-30912"/></a></p>
<p>
<strong>Goto Operation</strong></p>
<pre>Goto(I, X)
Initialise J to be the empty set;
for ( each item A -&gt; ?.X?, a ] in I )
    Add item A -&gt; ?X.?, a ] to se J;   /* move the dot one step */
return Closure(J);    /* apply closure to the set */
</pre>
<p>Eg-<br/>
<a href="https://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/parser_18.png"><img src="../../../imgs/compiler/33ba6141e277ed535d2627ac0932d8cb.jpg" alt="parser_18" width="632" height="334" class="alignnone size-full wp-image-30916"/></a><br/>
<br/>
<strong>LR(1) items</strong></p>
<pre>Void items(G’)
Initialise C to { closure ({[S’ -&gt; .S, $]})};
Repeat
    For (each set of items I in C)
        For (each grammar symbol X)
            if( GOTO(I, X) is not empty and not in C)
                Add GOTO(I, X) to C;
Until no new set of items are added to C;

</pre>
<p>
<strong>Construction of GOTO graph</strong></p>
<ul>
<li>State I<sub>0</sub> – closure of augmented LR(1) item. </li>
<li>Using I<sub>0</sub> find all collection of sets of LR(1) items with the help of DFA</li>
<li>Convert DFA to LR(1) parsing table</li>
</ul>
<p>
<strong>Construction of CLR parsing table-</strong><br/>
Input – augmented grammar G’</p>
<ol>
<li>Construct C = { I<sub>0</sub>, I<sub>1</sub>, ……. I<sub>n</sub>} , the collection of sets of LR(0) items for G’.</li>
<li>State i is constructed from Ii. The parsing actions for state i are determined as follow :<br/>
i) If [ A -&gt; ?.a?, b ] is in I<sub>i</sub> and GOTO(I<sub>i</sub> , a) = I<sub>j</sub>, then set ACTION[i, a] to “shift j”. Here a must be terminal.<br/>
ii) If [A -&gt; ?. , a] is in I<sub>i</sub> , A ≠ S, then set ACTION[i, a] to “reduce A -&gt; ?”.<br/>
iii) Is [S -&gt; S. , $ ] is in I<sub>i</sub>, then set action[i, $] to “accept”.<br/>
If any conflicting actions are generated by the above rules we say that the grammar is<br/>
not CLR.<p></p>
</li>
<li>The goto transitions for state i are constructed for all nonterminals A using the rule: if GOTO( I<sub>i</sub>, A ) = I<sub>j</sub> then GOTO [i, A] = j. </li>
<li>All entries not defined by rules 2 and 3 are made error. </li>
</ol>
<p>Eg:</p>
<pre>Consider the following grammar 
    S -&gt; AaAb | BbBa
    A -&gt; ?
    B -&gt; ?
    Augmented grammar - S’ -&gt; S
                  S -&gt; AaAb | BbBa
                  A -&gt; ?
                  B -&gt; ?
    GOTO graph for this grammar will be - 

</pre>
<p><a href="https://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/parser_19.png"><img src="../../../imgs/compiler/ebeed5e97a1128aca2a927201d405921.jpg" alt="parser_19" width="652" height="595" class="alignnone size-full wp-image-30933"/></a><br/>
<strong>Note</strong> – if a state has two reductions and both have same lookahead then it will in multiple entries in parsing table thus a conflict. If a state has one reduction and their is a shift from that state on a terminal same as the lookahead of the reduction then it will lead to multiple entries in parsing table thus a conflict.<br/>
<br/>
<strong>LALR PARSER</strong><br/>
LALR parser are same as CLR parser with one difference. In CLR parser if two states differ only in lookahead then we combine those states in LALR parser. After minimisation if the parsing table has no conflict that the grammar is LALR also.<br/>
Eg:</p>
<pre>consider the grammar S -&gt;AA
                     A -&gt; aA | b
    Augmented grammar - S’ -&gt; S
                        S -&gt;AA
                        A -&gt; aA | b

</pre>
<p><a href="https://www.geeksforgeeks.org/wp-content/uploads/gq/2017/02/parser_20.png"><img src="../../../imgs/compiler/6cb44ef1cf2383cff558eaaa193fef82.jpg" alt="parser_20" width="651" height="565" class="alignnone size-full wp-image-30938"/></a></p>
<p>
<strong>Important Notes</strong><br/>
1. Even though CLR parser does not have RR conflict but LALR may contain RR conflict.<br/>
2. If number of states LR(0) = n1,<br/>
&#160;   number of states SLR = n2,<br/>
&#160;   number of states LALR = n3,<br/>
 &#160;  number of states CLR = n4 then,<br/>
 &#160;  n1 = n2 = n3 &lt;= n4<br/>
<br/>
<a href="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/Parsing.jpg"><img src="../../../imgs/compiler/2c01ea4927531155b7f92ac1bef442c3.jpg" alt="parser_21" width="483" height="417" class="alignnone size-full wp-image-30948"/></a><br/>
<br/>
<br/></p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>