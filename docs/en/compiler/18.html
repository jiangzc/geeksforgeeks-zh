<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>

<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Ambiguous Grammar</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>&#160;<br/>
You can also read our previously discussed article on <a href="http://quiz.geeksforgeeks.org/classification-of-context-free-grammars/">Classification of Context Free Grammars.</a></p>
<p>&#160;<br/>
<strong>C</strong>ontext <strong>F</strong>ree <strong>G</strong>rammars(CFGs) are classified based on:</p>
<ul>
<li>Number of Derivation trees</li>
<li>Number of strings</li>
</ul>
<p>&#160;<br/>
Depending on Number of Derivation trees, CFGs are sub-divided into 2 types:</p>
<ul>
<li>Ambiguous grammars</li>
<li>Unambiguous grammars</li>
</ul>
<p>&#160;<br/>
<strong>Ambiguous grammar:</strong><br/>
&#160;<br/>
A CFG is said to ambiguous if there exists more than one derivation tree for the given input string i.e., more than one <strong>L</strong>eft<strong>M</strong>ost <strong>D</strong>erivation <strong>T</strong>ree (LMDT) or <strong>R</strong>ight<strong>M</strong>ost <strong>D</strong>erivation <strong>T</strong>ree (RMDT).<br/>
&#160;<br/>
<strong>Definition:</strong> G = (V,T,P,S) is a CFG is said to be ambiguous if and only if there exist a string in T* that has more than on parse tree.<br/>
where V is a finite set of variables.<br/>
T is a finite set of terminals.<br/>
P is a finite set of productions of the form, A -&gt; α, where A is a variable and α ∈ (V ∪ T)* S is a designated variable called the start symbol. &#160;<br/>
&#160;<br/>
<strong>For Example:</strong><br/>
&#160;<br/>
1. Let us consider this grammar : <strong>E -&gt; E+E|id</strong> </p>
<p>We can create 2 parse tree from this grammar to obtain a string <strong>id+id+id &#160;</strong> :</p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<p>The following are the 2 parse trees generated by left most derivation:</p>
<p><a href="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/grammertree.jpg"><img src="../../../imgs/compiler/93fc4924b9a5ad07b1e0960ca4b4e6c8.jpg" alt="parse trees (3)" width="538" height="337" class="aligncenter size-full wp-image-24875"/></a></p>
<p>Both the above parse trees are derived from same grammar rules but both parse trees are different. Hence the grammar is ambiguous. &#160;<br/>
&#160;<br/>
2. Let us now consider the following grammar:<br/>
&#160;</p>
<pre>Set of alphabets ∑ = {0,…,9, +, *, (, )}

E -&gt; I        
E -&gt; E + E
E -&gt; E * E
E -&gt; (E)
I -&gt; ε | 0 | 1 | … | 9
&#160;
</pre>
<p>From the above grammar String <strong>3*2+5</strong> can be derived in 2 ways:<br/>
&#160;</p>
<pre>I) First leftmost derivation                   II) Second leftmost derivation
        E=&gt;E*E                          E=&gt;E+E
         =&gt;I*E                           =&gt;E*E+E
         =&gt;3*E+E                                       =&gt;I*E+E
         =&gt;3*I+E                           =&gt;3*E+E
         =&gt;3*2+E                           =&gt;3*I+E
         =&gt;3*2+I                           =&gt;3*2+I
         =&gt;3*2+5                           =&gt;3*2+5

</pre>
<p>&#160;<br/>
Following are some examples of ambiguous grammars:<br/>
&#160;</p>
<ul>
<li>S-&gt; aS |Sa| Є</li>
<li>E-&gt; E +E | E*E| id</li>
<li>A -&gt; AA | (A) | a</li>
<li>S -&gt; SS|AB , A -&gt; Aa|a , B -&gt; Bb|b</li>
</ul>
<p>Whereas following grammars are unambiguous:<br/>
&#160;</p>
<ul>
<li>S -&gt; (L) | a, L -&gt; LS | S</li>
<li>S -&gt; AA , A -&gt; aA , A -&gt; b</li>
</ul>
<p><strong>Inherently ambiguous Language:</strong> &#160;<br/>
&#160;<br/>
Let L be a Context Free Language (CFL). If every Context Free Grammar G with Language L = L(G) is ambiguous, then L is said to be inherently ambiguous Language. Ambiguity is a property of grammar not languages. Ambiguous grammar is unlikely to be useful for a programming language, because two parse trees structures(or more) for the same string(program) implies two different meanings (executable programs) for the program. &#160;<br/>
&#160;<br/>
<strong>Note :</strong> Ambiguity of a grammar is undecidable, i.e. there is no particular algorithm for removing the ambiguity of a grammar, but we can remove ambiguity by: &#160;<br/>
&#160;<br/>
<strong>Disambiguate the grammar</strong> i.e., rewriting the grammar such that there is only one derivation or parse tree possible for a string of the language which the grammar represents. &#160;<br/>
&#160;</p>
<p>This article is compiled by <strong>Saikiran Goud Burra</strong>.<br/>
&#160;<br/>
</p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>