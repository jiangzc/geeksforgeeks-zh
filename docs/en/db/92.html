<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Database Management Systems | Set 5</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>Following Questions have been asked in GATE CS 2010 exam.<span id="more-20593"></span></p>
<p><strong>1) A relational schema for a train reservation database is given below.<br/>
Passenger (pid, pname, age)<br/>
Reservation (pid, class, tid)<br/>
</strong></p>
<pre><strong>Table: Passenger</strong>
pid   pname   age
-----------------
 0    Sachin   65
 1    Rahul    66
 2    Sourav   67
 3    Anil     69

<strong>Table : Reservation</strong>
pid  class  tid
---------------
 0    AC   8200
 1    AC   8201
 2    SC   8201
 5    AC   8203
 1    SC   8204
 3    AC   8202
</pre>
<p><strong>What pids are returned by the following SQL query for the above instance of the tables?</strong></p>
<pre>SLECT pid
FROM Reservation ,
WHERE class ‘AC’ AND
    EXISTS (SELECT *
       FROM Passenger
       WHERE age &gt; 65 AND
       Passenger. pid = Reservation.pid)
</pre>
<p>(A) 1, 0<br/>
(B) 1, 2<br/>
(C) 1, 3<br/>
(S) 1, 5</p>
<p>Answer (C)<br/>
When a subquery uses values from outer query, the subquery is called <a href="http://en.wikipedia.org/wiki/Correlated_subquery">correlated subquery</a>.  The correlated subquery is evaluated once for each row processed by the outer query.</p>
<br/>
        
          <!-- post_top_responsive -->
          
          
        <br/>
            
<p>The outer query selects 4 entries (with pids as 0, 1, 5, 3) from Reservation table. Out of these selected entries, the subquery returns Non-Null values only for 1 and 3.</p>
<p><br/><br/>
<strong>2) Which of the following concurrency control protocols ensure both conflict serialzability and freedom from deadlock?<br/>
I. 2-phase locking<br/>
II. Time-stamp ordering<br/>
</strong>(A) I only<br/>
(B) II only<br/>
(C) Both I and II<br/>
(D) Neither I nor II</p>
<p>Answer (B)<br/>
<a href="http://en.wikipedia.org/wiki/Two-phase_locking">2 Phase Locking (2PL)</a> is a concurrency control method that guarantees serializability. The protocol utilizes locks, applied by a transaction to data, which may block (interpreted as signals to stop) other transactions from accessing the same data during the transaction’s life. 2PL may be lead to deadlocks that result from the mutual blocking of two or more transactions. See the following situation, neither T3 nor T4 can make progress.<br/>
<a href="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/tabletransaction.jpg"><img src="../../../imgs/db/6f5be573bd994acedb6b939c89774285.jpg" alt="" width="300" height="460" class="aligncenter size-full wp-image-20623"/></a><br/>
<a href="http://en.wikipedia.org/wiki/Timestamp-based_concurrency_control">Timestamp-based concurrency control</a> algorithm is a non-lock concurrency control method. In Timestamp based method, deadlock cannot occur as no transaction ever waits.<br/>
<br/><br/><br/>
<strong>3) Consider the following schedule for transactions T1, T2 and T3:</strong><br/>
<a href="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/transaction3.jpg"><img src="../../../imgs/db/29d0d5938f66912764bf13d47c0f93ec.jpg" alt="" width="300" height="480" class="aligncenter size-full wp-image-20596"/></a><br/>
<strong>Which one of the schedules below is the correct serialization of the above?</strong><br/>
(A)T1 →T3 →T2<br/>
(B)T2 →T1 →T3<br/>
(C)T2 →T3 → T1<br/>
(D)T3 →T1 →T2</p>
<p>Answer (A)<br/>
T1 can complete before T2 and T3 as there is no conflict between Write(X) of T1 and the operations in T2 and T3 which occur before Write(X) of T1 in the above diagram.<br/>
T3 should can complete before T2 as the Read(Y) of T3 doesn’t conflict with Read(Y) of T2. Similarly, Write(X) of T3 doesn’t conflict with Read(Y) and Write(Y) operations of T2.<br/>
Another way to solve this question is to create a dependency graph and topologically sort the dependency graph. After topologically sorting, we can see the sequence T1, T3, T2.</p>
<p><br/><br/>
<strong>4) Which of the following functional dependencies hold for relations R(A, B, C) and S(B, D, E):<br/>
B → A,<br/>
A → C<br/>
The relation R contains 200 tuples and the rel ation S contains 100 tuples. What is the<br/>
maximum number of tuples possible in the natural join R◊◊S (R natural join S)<br/>
</strong>(A) 100<br/>
(B) 200<br/>
(D) 300<br/>
(D) 2000</p>
<p>Answer (A)<br/>
From the given set of functional dependencies, it can be observed that B is a candidate key of R. So all 200 values of B must be unique in R. There is no functional dependency given for S. To get the maximum number of tuples in output, there can be two possibilities for S.<br/>
1) All 100 values of B in S are same and there is an entry in R that matches with this value. In this case, we get 100 tuples in output.<br/>
2) All 100 values of B in S are different and these values are present in R also. In this case also, we get 100 tuples.</p>
<p><strong>Please see <a href="http://geeksquiz.com/gate-corner-2/">GATE Corner</a> for all previous year paper/solutions/explanations, syllabus, important dates, notes, etc.</strong></p>

<br/>
          <!-- post_bottom_responsive -->
          
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>