<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Closure Properties of Context Free Languages</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p>Context Free languages are accepted by <a href="http://quiz.geeksforgeeks.org/theory-of-computation-pushdown-automata/">pushdown automata</a> but not by finite automata. Context free languages can be generated by context free grammar which has the form :</p>
<p>A -&gt; ρ (where A ∈ N and ρ ∈ (T ∪ N)* and N is a non-terminal and T is a terminal)<br/>
&#160;<br/>
<strong>Properties of Context Free Languages</strong><br/>
<strong>Union :</strong> If L1 and If L2 are two context free languages, their union L1 ∪ L2 will also be context free. For example,<br/>
L1 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup> | m &gt;= 0 and n &gt;= 0 } and L2 = { a<sup>n</sup>b<sup>m</sup>c<sup>m</sup> | n &gt;= 0 and m &gt;= 0 }<br/>
L3 = L1 ∪ L2 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup> ∪ a<sup>n</sup>b<sup>m</sup>c<sup>m</sup> | n &gt;= 0, m &gt;= 0 } is also context free.<br/>
L1 says number of a’s should be equal to number of b’s and L2 says number of b’s should be equal to number of c’s. Their union says either of two conditions to be true. So it is also context free language.<br/>
&#160;<br/>
<strong>Concatenation :</strong> If L1 and If L2 are two context free languages, their concatenation L1.L2 will also be context free. For example,<br/>
L1 = { a<sup>n</sup>b<sup>n</sup> | n &gt;= 0 } and L2 = { c<sup>m</sup>d<sup>m</sup> | m &gt;= 0 }<br/>
L3 = L1.L2 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup> | m &gt;= 0 and n &gt;= 0} is also context free.<br/>
L1 says number of a’s should be equal to number of b’s and L2 says number of c’s should be equal to number of d’s. Their concatenation says first number of a’s should be equal to number of b’s, then number of c’s should be equal to number of d’s. So, we can create a PDA which will first push for a’s, pop for b’s, push for c’s then pop for d’s. So it can be accepted by pushdown automata, hence context free.<br/>
&#160;<br/>
<strong>Kleene Closure :</strong> If L1 is context free, its Kleene closure L1* will also be context free. For example,<br/>
L1 = { a<sup>n</sup>b<sup>n</sup> | n &gt;= 0 }<br/>
L1* = { a<sup>n</sup>b<sup>n</sup> | n &gt;= 0 }* is also context free.<br/>
&#160;<br/>
<strong>Intersection and complementation :</strong> If L1 and If L2 are two context free languages, their intersection L1 ∩ L2 need not be context free. For example,<br/>
L1 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup> | n &gt;= 0 and m &gt;= 0 } and L2 = (a<sup>m</sup>b<sup>n</sup>c<sup>n</sup> | n &gt;= 0 and m &gt;= 0 }<br/>
L3 = L1 ∩ L2 = { a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> | n &gt;= 0 } need not be context free.<br/>
L1 says number of a’s should be equal to number of b’s and L2 says number of b’s should be equal to number of c’s. Their intersection says both conditions need to be true, but push down automata can compare only two. So it cannot be accepted by pushdown automata, hence not context free.<br/>
Similarly, complementation of context free language L1 which is ∑* – L1, need not be context free.<br/>
&#160;<br/>
<strong>Deterministic Context-free Languages</strong><br/>
Deterministic CFL are subset of CFL which can be recognized by Deterministic PDA. Deterministic PDA has only one move from a given state and input symbol. For example, L1= { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup> | m &gt;= 0 and n &gt;= 0} is a DCFL because for a’s, we can push on stack and for b’s we can pop. It can be recognized by Deterministic PDA. On the other hand, L3 = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup> ∪ a<sup>n</sup>b<sup>m</sup>c<sup>m</sup> | n &gt;= 0, m &gt;= 0 } cannot be recognized by DPDA because either number of a’s and b’s can be equal or either number of b’s and c’s can be equal. So, it can only be implemented by NPDA. Thus, it is CFL but not DCFL.<br/>
<strong>Note :</strong> Out of union, concatenation, complementation, intersection and kleene-closure, DCFL are closed only under complementation.<br/>
&#160;<br/>
<strong>Question :</strong> Consider the language L1,L2,L3 as given below.<br/>
L1 = { a<sup>m</sup>b<sup>n</sup> | m, n &gt;= 0 }<br/>
L2 = { a<sup>n</sup>b<sup>n</sup> | n &gt;= 0 }<br/>
L3 = { a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> | n &gt;= 0 }<br/>
Which of the following statements is NOT TRUE?<br/>
A. Push Down Automata (PDA) can be used to recognize L1 and L2<br/>
B. L1 is a regular language<br/>
C. All the three languages are context free<br/>
D. Turing machine can be used to recognize all the three languages</p>
<p><strong>Solution :</strong> Option (A) says PDA can be used to recognize L1 and L2. L1 contains all strings with any no. of a followed by any no. of b. So, it can be accepted by PDA. L2 contains strings with n no. of a’s followed by n no. of b’s. It can also be accepted by PDA. So, option (A) is correct.<br/>
Option (B) says that L1 is regular. It is true as regular expression for L1 is a*b*.<br/>
Option (C) says L1, L2 and L3 are context free. L3 languages contains all strings with n no. of a’s followed by n no. of b’s followed by n no. of c’s. But it can’t be accepted by PDA. So option ( C) is not correct.<br/>
Option (D) is correct as Turing machine can be used to recognize all the three languages.</p>
<p>&#160;<br/>
<strong>Question :</strong> The language L = { 0<sup>i</sup>12<sup>i</sup> | i ≥ 0 } over the alphabet {0, 1, 2} is :<br/>
A. Not recursive<br/>
B. Is recursive and deterministic CFL<br/>
C. Is regular<br/>
D. Is CFL bot not deterministic CFL.</p>
<p><strong>Solution :</strong> The above language is deterministic CFL as for 0’s, we can push 0 on stack and for 2’s we can pop corresponding 0’s. As there is no ambiguity which moves to take, it is deterministic. So, correct option is (B). As CFL is subset of recursive, it is recursive as well.<br/>
&#160;<br/>
<strong>Question :</strong> Consider the following languages:<br/>
L1 = { 0<sup>n</sup>1<sup>n</sup>| n≥0 }<br/>
L2 = { wcwr | w ɛ {a,b}* }<br/>
L3 = { wwr | w ɛ {a,b}* }<br/>
Which of these languages are deterministic context-free languages?<br/>
A. None of the languages<br/>
B. Only L1<br/>
C. Only L1 and L2<br/>
D. All three languages</p>
<p><strong>Solution :</strong> Languages L1 contains all strings in which n 0’s are followed by n 1’s. Deterministic PDA can be constructed to accept L1. For 0’s we can push it on stack and for 1’s, we can pop from stack. Hence, it is DCFL.<br/>
L2 contains all strings of form wcwr where w is a string of a’s and b’s and wr is reverse of w. For example, aabbcbbaa. To accept this language, we can construct PDA which will push all symbols on stack before c. After c, if symbol on input string matches with symbol on stack, it is popped. So, L2 can also be accepted with deterministic PDA, hence it is also DCFL.<br/>
L3 contains all strings of form wwr where w is a string of a’s and b’s and wr is reverse of w. But we don’t know where w ends and wr starts. e.g.; aabbaa is a string corresponding to L3. For first a, we will push it on stack. Next a can be either part of w or wr where w=a. So, there can be multiple moves from a state on an input symbol. So, only non-deterministic PDA can be used to accept this type of language. Hence, it is NCFL not DCFL.<br/>
So, correct option is (C). Only, L1 and L2 are DCFL.<br/>
&#160;<br/>
<strong>Question :</strong> Which one of the following grammars generate the language L = { a<sup>i</sup>b<sup>j</sup> | i ≠ j }<br/>
S -&gt; AC | CB, C -&gt; aCb | a | b, A -&gt; aA | ɛ, B -&gt; Bb | ɛ<br/>
S -&gt; aS | Sb | a | b<br/>
S -&gt; AC | CB, C -&gt; aCb | ɛ, A -&gt; aA | ɛ, B -&gt; Bb | ɛ<br/>
S -&gt; AC | CB, C -&gt; aCb | ɛ, A -&gt; aA | a, B -&gt; Bb | b</p>
<p><strong>Solution :</strong> The best way to solve these type of questions is to eliminate options which do not satisfy conditions. The conditions for language L is no. of a’s and no. of b’s should be unequal.<br/>
In option (B), S =&gt; aS =&gt; ab. It can generate strings with equal a’s and b’s. So, this option is incorrect.<br/>
In option (C), S =&gt; AC =&gt; C =&gt; ɛ. In ɛ, a’s and b’s are equal (0), so it is not correct option.<br/>
In option (A), S will be replaced by either AC or CB. C will either generate no. of a’s more than no. of  b’s by 1  or  no. of b’s more than no. of  a’s by 1. But one more a or one more b can be compensated by B -&gt; bB | ɛ or A -&gt; aA | ɛ respectively. So it may give strings with equal no. of a’s and b’s. So, it is not a correct option.<br/>
In option (D), S will be replaced by either AC or CB. C will always generate equal no. of a’s and b’s. If we replace S by AC, A with add atleast one extra a. and if we replace S by CB, B will add atleast one extra b. So this grammar will never generate equal no. of a’s and b’s. So, option (D) is correct.<br/>
&#160;<br/>
<br/>
&#160;<br/>
</p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>