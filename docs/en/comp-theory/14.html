<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Program to Implement NFA with epsilon move to DFA Conversion</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p><strong>Non-determinestic Finite Automata (NFA) :</strong>  NFA is a finite automaton where for some cases when a single input is given to a single state, the machine goes to more than 1 states, i.e. some of the moves cannot be uniquely determined by the present state and the present input symbol.</p>
<pre>An NFA can be represented as <strong>M = { Q, ∑, ∂, q0, F}</strong></pre>
<blockquote>
<p>Q → Finite non-empty set of states.<br/>
∑ → Finite non-empty set of input symbols.<br/>
∂ → Transitional Function.<br/>
q0 → Beginning state.<br/>
F → Final State
</p>
</blockquote>
<p>
<strong>NFA with (null) or ∈ move :</strong> If any finite automata contains ε (null) move or transaction, then that finite automata is called NFA with ∈ moves
</p>
<p>
<strong>Example :  </strong><br/>
Consider the following figure of NFA with ∈ move :</p>
<p><img src="../../../imgs/comp-theory/b05ea6543743cd7a99a2645373d8ac87.jpg" alt="" width="500" height="200" class="alignnone size-medium wp-image-314790"/><br/>
<strong>Transition state table for the above NFA </strong></p>
<table style="border :2px solid black">
<tbody><tr style="border :2px solid black">
<th style="border :2px solid black">STATES</th>
<th style="border :2px solid black">0</th>
<th style="border :2px solid black">1</th>
<th>epsilon</th>
</tr>
<tr style="border :2px solid black">
<th style="border :2px solid black">A</th>
<th style="border :2px solid black">B, C</th>
<th style="border :2px solid black">A</th>
<th style="border :2px solid black">B</th>
</tr>
<tr style="border :2px solid black">
<th style="border :2px solid black">B</th>
<th style="border :2px solid black">–</th>
<th style="border :2px solid black">B</th>
<th style="border :2px solid black">C</th>
</tr>
<tr style="border :2px solid black">
<th style="border :2px solid black">C</th>
<th style="border :2px solid black">C</th>
<th style="border :2px solid black">C</th>
<th style="border :2px solid black">–</th>
</tr>
</tbody>
</table>
<p>
<strong>Epsilon (∈) – closure :</strong> Epsilon closure for a given state X is a set of states which can be reached from the states X with only (null) or ε moves including the state X itself. In other words, ε-closure for a state can be obtained by union operation of the ε-closure of the states which can be reached from X with a single ε move in recursive manner. </p>
<p>For the above example ∈ closure are as follows :</p>
<pre><strong>∈ closure(A) :</strong> {A, B, C}
<strong>∈ closure(B) :</strong> {B, C}
<strong>∈ closure(C) :</strong> {C}</pre>
<p></p>
<p>&#160;<br/>
<strong>Deterministic Finite Automata (DFA) :</strong> DFA is a finite automata where, for all cases, when a single input is given to a single state, the machine goes to a single state, i.e., all the moves of the machine can be uniquely determined by the present state and the present input symbol.</p>
<p></p>
<h4 class="sigil_not_in_toc">Steps to Convert NFA with ε-move to DFA :</h4>
<blockquote><p>
<strong>Step 1 :</strong> Take ∈ closure for the beginning state of NFA as beginning state of DFA.<br/>
<strong>Step 2 :</strong> Find the states that can be traversed from the present for each input symbol<br/>
(union of transition value and their closures for each states of NFA present in current state of DFA).</p>
<p><strong>Step 3 :</strong> If any new state is found take it as current state and repeat step 2.<br/>
<strong>Step 4 :</strong> Do repeat Step 2 and Step 3 until no new  state present in DFA transition table.<br/>
<strong>Step 5 :</strong> Mark the states of DFA which contains final state of NFA as final states of DFA.</p>
</blockquote>
<p><strong>Transition State Table for DFA corresponding to above NFA</strong></p>
<table style="border :3px solid black">
<tbody><tr style="border :3px solid black">
<th style="border :3px solid black">STATES</th>
<th style="border :3px solid black">0</th>
<th style="border :3px solid black">1</th>
</tr>
<tr style="border :3px solid black">
<th style="border :3px solid black">A, B, C</th>
<th style="border :3px solid black">B, C</th>
<th style="border :3px solid black">A, B, C</th>
</tr>
<tr>
<th style="border :3px solid black">B, C</th>
<th style="border :3px solid black">C</th>
<th style="border :3px solid black">B, C</th>
</tr>
<tr style="border :3px solid black">
<th style="border :3px solid black">C</th>
<th style="border :3px solid black">C</th>
<th style="border :3px solid black">C</th>
</tr>
</tbody>
</table>
<p><strong> DFA STATE DIAGRAM</strong><br/>
<img src="../../../imgs/comp-theory/c95ffbdc6f28acc5c9c29cb520724c6a.jpg" alt="" class="alignnone size-medium wp-image-314801"/></p>
<p>Examples :</p>
<pre><strong>Input :</strong> 6
        2
        FC - BF
        - C -
        - - D
        E A -
        A - BF
        - - -


<strong>Output :</strong>
 STATES OF NFA :        A, B, C, D, E, F,

 GIVEN SYMBOLS FOR NFA:     0, 1, eps


 NFA STATE TRANSITION TABLE 


STATES    |0    |1    eps
--------+------------------------------------
A    |FC     |-     |BF     
B    |-     |C     |-     
C    |-     |-     |D     
D    |E     |A     |-     
E    |A     |-     |BF     
F    |-     |-     |-     

 e-Closure (A) :    ABF

 e-Closure (B) :    B

 e-Closure (C) :    CD

 e-Closure (D) :    D

 e-Closure (E) :    BEF

 e-Closure (F) :    F


********************************************************

         DFA TRANSITION STATE TABLE          


 STATES OF DFA :        ABF, CDF, CD, BEF,

 GIVEN SYMBOLS FOR DFA:     0, 1,

STATES    |0    |1    
--------+-----------------------
ABF    |CDF     |CD     
CDF    |BEF     |ABF     
CD    |BEF     |ABF     
BEF    |ABF     |CD     



<strong>Input :</strong>
9
2
- - BH
- - CE
D - -
- - G
- F -
- - G
- - BH
I - -
- -  -


<strong>Output :</strong>

STATES OF NFA :        A, B, C, D, E, F, G, H, I,

 GIVEN SYMBOLS FOR NFA:     0, 1, eps


 NFA STATE TRANSITION TABLE 


STATES    |0    |1    eps
--------+------------------------------------
A    |-     |-     |BH     
B    |-     |-     |CE     
C    |D     |-     |-     
D    |-     |-     |G     
E    |-     |F     |-     
F    |-     |-     |G     
G    |-     |-     |BH     
H    |I     |-     |-     
I    |-     |-     |-     

 e-Closure (A) :    ABCEH

 e-Closure (B) :    BCE

 e-Closure (C) :    C

 e-Closure (D) :    BCDEGH

 e-Closure (E) :    E

 e-Closure (F) :    BCEFGH

 e-Closure (G) :    BCEGH

 e-Closure (H) :    H

 e-Closure (I) :    I


********************************************************

         DFA TRANSITION STATE TABLE          


 STATES OF DFA :        ABCEH, BCDEGHI, BCEFGH,

 GIVEN SYMBOLS FOR DFA:     0, 1,

STATES    |0    |1    
--------+-----------------------
ABCEH    |BCDEGHI     |BCEFGH     
BCDEGHI    |BCDEGHI     |BCEFGH     
BCEFGH    |BCDEGHI     |BCEFGH     

</pre>
<p><br/><br/>
<!-- To show strongly recommend and practice link    --></p>
<div id="practiceLinkDiv">
<h2 class="sigil_not_in_toc"><a href="https://ide.geeksforgeeks.org/">Recommended: Please try your approach on <b><i><u>{IDE}</u></i></b> first, before moving on to the solution.</a></h2>
</div>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<p><strong>Explanation :</strong><br/>
First line of the input contains the number of states (<strong>N</strong>) of NFA. Second line of the input says the number of input symbols (<strong>S</strong>). In example1 number of states of NFA is 6 i.e.(<strong> A, B, C, D, E, F</strong>) and 2 input symbols i.e. (<strong> 0, 1</strong>). Since we are working on NFA with ∈ move, <strong>∈</strong> will be added as an extra input symbol. The next <strong>N </strong> lines contains the transition values for every state of NFA. The value of ith row, jth column indicates transition value for ith state on jth input symbol. Here in example1 <strong>transition(A, 0) :  FC</strong>.</p>
<p>Output contains the NFA, ∈ closure for every states of the corresponding NFA and  DFA obtained by converting the input NFA. States and input symbols of the DFA are also specified.</p>
<p>Below is the implementation of above approach :</p>
<pre class="brush: c; title: ; notranslate" title="">// C Program to illustrate how to convert e-nfa to DFA

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX_LEN 100

char NFA_FILE[MAX_LEN];
char buffer[MAX_LEN];
int zz = 0;

// Structure to store DFA states and their
// status ( i.e new entry or already present)
struct DFA {
  char *states;
  int count;
} dfa;

int last_index = 0;
FILE *fp;
int symbols;

/* reset the hash map*/
void reset(int ar[], int size) {
  int i;

  // reset all the values of
  // the mapping array to zero
  for (i = 0; i &lt; size; i++) {
    ar[i] = 0;
  }
}

// Check which States are present in the e-closure

/* map the states of NFA to a hash set*/
void check(int ar[], char S[]) {
  int i, j;

  // To parse the individual states of NFA
  int len = strlen(S);
  for (i = 0; i &lt; len; i++) {

    // Set hash map for the position
    // of the states which is found
    j = ((int)(S[i]) - 65);
    ar[j]++;
  }
}

// To find new Closure States
void state(int ar[], int size, char S[]) {
  int j, k = 0;

  // Combine multiple states of NFA
  // to create new states of DFA
  for (j = 0; j &lt; size; j++) {
    if (ar[j] != 0)
      S[k++] = (char)(65 + j);
  }

  // mark the end of the state
  S[k] = '\0';
}

// To pick the next closure from closure set
int closure(int ar[], int size) {
  int i;

  // check new closure is present or not
  for (i = 0; i &lt; size; i++) {
    if (ar[i] == 1)
      return i;
  }
  return (100);
}

// Check new DFA states can be
// entered in DFA table or not
int indexing(struct DFA *dfa) {
  int i;

  for (i = 0; i &lt; last_index; i++) {
    if (dfa[i].count == 0)
      return 1;
  }
  return -1;
}

/* To Display epsilon closure*/
void Display_closure(int states, int closure_ar[],
                     char *closure_table[],
                     char *NFA_TABLE[][symbols + 1],
                     char *DFA_TABLE[][symbols]) {
  int i;
  for (i = 0; i &lt; states; i++) {
    reset(closure_ar, states);
    closure_ar[i] = 2;

    // to neglect blank entry
    if (strcmp(&amp;NFA_TABLE[i][symbols], "-") != 0) {

      // copy the NFA transition state to buffer
      strcpy(buffer, &amp;NFA_TABLE[i][symbols]);
      check(closure_ar, buffer);
      int z = closure(closure_ar, states);

      // till closure get completely saturated
      while (z != 100)
      {
        if (strcmp(&amp;NFA_TABLE[z][symbols], "-") != 0) {
          strcpy(buffer, &amp;NFA_TABLE[z][symbols]);

          // call the check function
          check(closure_ar, buffer);
        }
        closure_ar[z]++;
        z = closure(closure_ar, states);
      }
    }

    // print the e closure for every states of NFA
    printf("\n e-Closure (%c) :\t", (char)(65 + i));

    bzero((void *)buffer, MAX_LEN);
    state(closure_ar, states, buffer);
    strcpy(&amp;closure_table[i], buffer);
    printf("%s\n", &amp;closure_table[i]);
  }
}

/* To check New States in DFA */
int new_states(struct DFA *dfa, char S[]) {

  int i;

  // To check the current state is already
  // being used as a DFA state or not in
  // DFA transition table
  for (i = 0; i &lt; last_index; i++) {
    if (strcmp(&amp;dfa[i].states, S) == 0)
      return 0;
  }

  // push the new
  strcpy(&amp;dfa[last_index++].states, S);

  // set the count for new states entered
  // to zero
  dfa[last_index - 1].count = 0;
  return 1;
}

// Transition function from NFA to DFA
// (generally union of closure operation )
void trans(char S[], int M, char *clsr_t[], int st,
               char *NFT[][symbols + 1], char TB[]) {
  int len = strlen(S);
  int i, j, k, g;
  int arr[st];
  int sz;
  reset(arr, st);
  char temp[MAX_LEN], temp2[MAX_LEN];
  char *buff;

  // Transition function from NFA to DFA
  for (i = 0; i &lt; len; i++) {

    j = ((int)(S[i] - 65));
    strcpy(temp, &amp;NFT[j][M]);

    if (strcmp(temp, "-") != 0) {
      sz = strlen(temp);
      g = 0;

      while (g &lt; sz) {
        k = ((int)(temp[g] - 65));
        strcpy(temp2, &amp;clsr_t[k]);
        check(arr, temp2);
        g++;
      }
    }
  }

  bzero((void *)temp, MAX_LEN);
  state(arr, st, temp);
  if (temp[0] != '\0') {
    strcpy(TB, temp);
  } else
    strcpy(TB, "-");
}

/* Display DFA transition state table*/
void Display_DFA(int last_index, struct DFA *dfa_states,
                 char *DFA_TABLE[][symbols]) {
  int i, j;
  printf("\n\n********************************************************\n\n");
  printf("\t\t DFA TRANSITION STATE TABLE \t\t \n\n");
  printf("\n STATES OF DFA :\t\t");

  for (i = 1; i &lt; last_index; i++)
    printf("%s, ", &amp;dfa_states[i].states);
  printf("\n");
  printf("\n GIVEN SYMBOLS FOR DFA: \t");

  for (i = 0; i &lt; symbols; i++)
    printf("%d, ", i);
  printf("\n\n");
  printf("STATES\t");

  for (i = 0; i &lt; symbols; i++)
    printf("|%d\t", i);
  printf("\n");

  // display the DFA transition state table
  printf("--------+-----------------------\n");
  for (i = 0; i &lt; zz; i++) {
    printf("%s\t", &amp;dfa_states[i + 1].states);
    for (j = 0; j &lt; symbols; j++) {
      printf("|%s \t", &amp;DFA_TABLE[i][j]);
    }
    printf("\n");
  }
}

// Driver Code
int main() {
  int i, j, states;
  char T_buf[MAX_LEN];

  // creating an array dfa structures
  struct DFA *dfa_states = malloc(MAX_LEN * (sizeof(dfa)));
  states = 6, symbols = 2;

  printf("\n STATES OF NFA :\t\t");
  for (i = 0; i &lt; states; i++)

    printf("%c, ", (char)(65 + i));
  printf("\n");
  printf("\n GIVEN SYMBOLS FOR NFA: \t");

  for (i = 0; i &lt; symbols; i++)

    printf("%d, ", i);
  printf("eps");
  printf("\n\n");
  char *NFA_TABLE[states][symbols + 1];

  // Hard coded input for NFA table
  char *DFA_TABLE[MAX_LEN][symbols];
  strcpy(&amp;NFA_TABLE[0][0], "FC");
  strcpy(&amp;NFA_TABLE[0][1], "-");
  strcpy(&amp;NFA_TABLE[0][2], "BF");
  strcpy(&amp;NFA_TABLE[1][0], "-");
  strcpy(&amp;NFA_TABLE[1][1], "C");
  strcpy(&amp;NFA_TABLE[1][2], "-");
  strcpy(&amp;NFA_TABLE[2][0], "-");
  strcpy(&amp;NFA_TABLE[2][1], "-");
  strcpy(&amp;NFA_TABLE[2][2], "D");
  strcpy(&amp;NFA_TABLE[3][0], "E");
  strcpy(&amp;NFA_TABLE[3][1], "A");
  strcpy(&amp;NFA_TABLE[3][2], "-");
  strcpy(&amp;NFA_TABLE[4][0], "A");
  strcpy(&amp;NFA_TABLE[4][1], "-");
  strcpy(&amp;NFA_TABLE[4][2], "BF");
  strcpy(&amp;NFA_TABLE[5][0], "-");
  strcpy(&amp;NFA_TABLE[5][1], "-");
  strcpy(&amp;NFA_TABLE[5][2], "-");
  printf("\n NFA STATE TRANSITION TABLE \n\n\n");
  printf("STATES\t");

  for (i = 0; i &lt; symbols; i++)
    printf("|%d\t", i);
  printf("eps\n");

  // Displaying the matrix of NFA transition table
  printf("--------+------------------------------------\n");
  for (i = 0; i &lt; states; i++) {
    printf("%c\t", (char)(65 + i));

    for (j = 0; j &lt;= symbols; j++) {
      printf("|%s \t", &amp;NFA_TABLE[i][j]);
    }
    printf("\n");
  }
  int closure_ar[states];
  char *closure_table[states];

  Display_closure(states, closure_ar, closure_table, NFA_TABLE, DFA_TABLE);
  strcpy(&amp;dfa_states[last_index++].states, "-");

  dfa_states[last_index - 1].count = 1;
  bzero((void *)buffer, MAX_LEN);

  strcpy(buffer, &amp;closure_table[0]);
  strcpy(&amp;dfa_states[last_index++].states, buffer);

  int Sm = 1, ind = 1;
  int start_index = 1;

  // Filling up the DFA table with transition values
  // Till new states can be entered in DFA table
  while (ind != -1) {
    dfa_states[start_index].count = 1;
    Sm = 0;
    for (i = 0; i &lt; symbols; i++) {

      trans(buffer, i, closure_table, states, NFA_TABLE, T_buf);

      // storing the new DFA state in buffer
      strcpy(&amp;DFA_TABLE[zz][i], T_buf);

      // parameter to control new states
      Sm = Sm + new_states(dfa_states, T_buf);
    }
    ind = indexing(dfa_states);
    if (ind != -1)
      strcpy(buffer, &amp;dfa_states[++start_index].states);
    zz++;
  }
  // display the DFA TABLE
  Display_DFA(last_index, dfa_states, DFA_TABLE);

  return 0;
}
</pre>
<p>
<strong>Use of NFA with ∈ move :</strong> If we want to construct an FA which accepts a language, sometimes it becomes very difficult or seems to be impossible to construct a direct NFA or DFA. But if NFA with ∈ moves is used, then the transitional diagram can be constructed and described easily.</p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/><hr/>

<hr/>

					
		
<!-- .entry-meta -->	</div>
</body>
</html>