<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title></title>
<link href="../../../styles/ebook.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<header class="entry-header">
						<h1 class="entry-title">Recursive and Recursive Enumerable Languages</h1>
				
						</header>
<!-- .entry-header -->
				<div class="entry-content">
			<p style="text-align: justify"><strong>Recursive Enumerable (RE) or Type -0 Language</strong></p>
<p style="text-align: justify">RE languages or type-0 languages are generated by type-0 grammars. An RE language can be accepted or recognized by Turing machine which means it will enter into final state for the strings of language and may or may not enter into rejecting state for the strings which are not part of the language. It means TM can loop forever for the strings which are not a part of the language. RE languages are also called as Turing recognizable languages.</p>
<p style="text-align: justify"><strong>Recursive Language (REC)</strong></p>
<p style="text-align: justify">A recursive language (subset of RE) can be decided by Turing machine which means it will enter into final state for the strings of language and rejecting state for the strings which are not part of the language. e.g.; L= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>|n&gt;=1} is recursive because we can construct a turing machine which will move to final state if the string is of the form anbncn else move to non-final state. So the TM will always halt in this case. REC languages are also called as Turing decidable languages. The relationship between RE and REC languages can be shown in Figure 1.<br/>
<img src="../../../imgs/comp-theory/15c5c757736cd815394a62151cd6a58f.jpg" alt="" class="aligncenter size-full wp-image-178684"/></p>
<p style="text-align: justify"><strong>Closure Properties of Recursive Languages</strong></p>
<br/>
        
          <!-- post_top_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4501693235" data-ad-format="auto"></ins>
          
        <br/>
            
<ul style="text-align: justify">
<li><strong>Union</strong>: If L1 and If L2 are two recursive languages, their union L1∪L2 will also be recursive because if TM halts for L1 and halts for L2, it will also halt for L1∪L2.</li>
<li><strong>Concatenation:</strong> If L1 and If L2 are two recursive languages, their concatenation L1.L2 will also be recursive.&#160;For Example:
<pre>    L1= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>|n&gt;=0} 
    L2= {d<sup>m</sup>e<sup>m</sup>f<sup>m</sup>|m&gt;=0}
    L3= L1.L2
    = {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>d<sup>m</sup> e<sup>m</sup>f<sup>m</sup>|m&gt;=0 and n&gt;=0} is also recursive.
</pre>
<p>L1 says n no. of a’s followed by n no. of b’s followed by n no. of c’s. L2 says m no. of d’s followed by m no. of e’s followed by m no. of f’s. Their concatenation first matches no. of a’s, b’s and c’s and then matches no. of d’s, e’s and f’s. So it can be decided by TM.</p></li>
<li><strong>Kleene Closure:</strong> If L1is recursive, its kleene closure L1* will also be recursive.&#160;For Example:</li>
</ul>
<pre>         L1= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>|n&gt;=0}
         L1*= { a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>||n&gt;=0}* is also recursive.
</pre>
<ul style="text-align: justify">
<li><strong>Intersection and complement</strong>: If L1 and If L2 are two recursive languages, their intersection L1 ∩ L2 will also be recursive. For Example:
<pre>    L1= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>dm|n&gt;=0 and m&gt;=0} 
    L2= {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>d<sup>n</sup>|n&gt;=0 and m&gt;=0}
    L3=L1 ∩ L2
    = { a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>d<sup>n</sup> |n&gt;=0} will be recursive.
</pre>
<p style="text-align: justify">L1 says n no. of a’s followed by n no. of b’s followed by n no. of c’s and then any no. of d’s. L2 says any no. of a’s followed by n no. of b’s followed by n no. of c’s followed by n no. of d’s. Their intersection says n no. of a’s followed by n no. of b’s followed by n no. of c’s followed by n no. of d’s. So it can be decided by turing machine, hence recursive.<br/>
Similarly, complementof recursive language L1 which is ∑*-L1, will also be recursive.</p>
</li>
</ul>
<p style="text-align: justify"><em>Note: As opposed to REC languages, RE languages are not closed under complementon which means complement of RE language need not be RE.</em></p>
<p style="text-align: center"><strong>GATE&#160;Questions&#160;</strong></p>
<p style="text-align: justify"><strong> Question 1: Which of the following statements is/are FALSE?</strong><br/>
1.For every non-deterministic TM, there exists an equivalent deterministic TM.<br/>
2.Turing recognizable languages are closed under union and complementation.<br/>
3.Turing decidable languages are closed under intersection and complementation.<br/>
4.Turing recognizable languages are closed under union and intersection.</p>
<p style="text-align: justify">A.1 and 4<br/>
B.1 and 3<br/>
C.2<br/>
D.3</p>
<p style="text-align: justify"><strong>Solution:</strong></p>
<p style="text-align: justify">Statement 1 is true as we can convert every non-deterministic TM to deterministic TM.<br/>
Statement 2 is false as Turing recognizable languages (RE languages) are not closed under complementation.<br/>
Statement 3 is true as Turing decidable languages (REC languages) are closed under intersection and complementation.<br/>
Statement 4 is true as Turing recognizable languages (RE languages) are closed under union and intersection.</p>
<p style="text-align: justify"><strong>Question 2 : Let L be a language and L’ be its complement. Which one of the following is NOT a viable possibility?</strong><br/>
A.Neither L nor L’ is RE.<br/>
B.One of L and L’ is RE but not recursive; the other is not RE.<br/>
C.Both L and L’ are RE but not recursive.<br/>
D.Both L and L’ are recursive.</p>
<p style="text-align: justify"><strong>Solution:</strong></p>
<p style="text-align: justify">Option A is correct because if L is not RE, its complementation will not be RE. Option B is correct because if L is RE, L’ need not be RE or vice versa because RE languages are not closed under complementation.<br/>
Option C is false because if L is RE, L’ will not be RE. But if L is recursive, L’ will also be recursive and both will be RE as well because REC languages are subset of RE. As they have mentioned not to be REC, so option is false.<br/>
Option D is correct because if L is recursive L’ will also be recursive.</p>
<p style="text-align: justify"><strong>Question 3:</strong> Let L1 be a recursive language, and let L2 be a recursively enumerable but not a recursive language. Which one of the following is TRUE?</p>
<p style="text-align: justify">A.L1′ is recursive and L2′ is recursively enumerable<br/>
B.L1′ is recursive and L2′ is not recursively enumerable<br/>
C.L1′ and L2′ are recursively enumerable<br/>
D.L1′ is recursively enumerable and L2′ is recursive<br/>
<strong>Solution:</strong></p>
<p style="text-align: justify">Option A is False as L2’ can’t be recursive enumerable (L2 is RE and RE are not closed under complementation).<br/>
Option B is correct as L1’ is REC (REC languages are closed under complementation) and L2’ is not recursive enumerable (RE languages are not closed under complementation).<br/>
Option C is False as L2’ can’t be recursive enumerable (L2 is RE and RE are not closed under complementation).<br/>
Option D is False as L2’ can’t be recursive enumerable (L2 is RE and RE languages are not closed under complementation). As REC languages are subset of RE, L2’ can’t be REC as well.</p>
<br/>
          <!-- post_bottom_responsive -->
          <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9465609616171866" data-ad-slot="8385097921" data-ad-format="auto"></ins>
          
            <br/><br/>
					
		
<!-- .entry-meta -->	</div>
</body>
</html>